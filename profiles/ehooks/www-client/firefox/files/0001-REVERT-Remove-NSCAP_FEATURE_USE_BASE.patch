From 373447e21c3b2e30033cc6b20347a1458c0704a4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Emilio=20Cobos=20=C3=81lvarez?= <emilio@crisal.io>
Date: Wed, 31 May 2023 21:01:04 +0000
Subject: [PATCH] REVERT: Bug 1835119 - Remove NSCAP_FEATURE_USE_BASE.
 r=xpcom-reviewers,kmag

This is not needed since bug 1363754. I left this as a follow-up
clean-up to mitigate a bit the risk of that change.

Differential Revision: https://phabricator.services.mozilla.com/D179123
---
 xpcom/base/nsCOMPtr.h | 125 +++++++++++++++++++++++++++++++++---------
 1 file changed, 100 insertions(+), 25 deletions(-)

diff --git a/xpcom/base/nsCOMPtr.h b/xpcom/base/nsCOMPtr.h
index 3ee56e9800..103587050f 100644
--- a/xpcom/base/nsCOMPtr.h
+++ b/xpcom/base/nsCOMPtr.h
@@ -47,8 +47,11 @@
 #  pragma warning(disable : 4514)
 #endif
 
+// #define NSCAP_FEATURE_USE_BASE
+
 #ifdef DEBUG
 #  define NSCAP_FEATURE_TEST_DONTQUERY_CASES
+#  undef NSCAP_FEATURE_USE_BASE
 #endif
 
 #ifdef __GNUC__
@@ -63,6 +66,10 @@
 #  define NS_MAY_ALIAS_PTR(t) t*
 #endif
 
+#if defined(NSCAP_DISABLE_DEBUG_PTR_TYPES)
+#  define NSCAP_FEATURE_USE_BASE
+#endif
+
 /*
  * The following three macros (NSCAP_ADDREF, NSCAP_RELEASE, and
  * NSCAP_LOG_ASSIGNMENT) allow external clients the ability to add logging or
@@ -150,6 +157,7 @@ class MOZ_STACK_CLASS nsQueryInterfaceISupports {
   nsISupports* MOZ_OWNING_REF mRawPtr;
 };
 
+#ifndef NSCAP_FEATURE_USE_BASE
 template <typename T>
 class MOZ_STACK_CLASS nsQueryInterface final
     : public nsQueryInterfaceISupports {
@@ -161,6 +169,7 @@ class MOZ_STACK_CLASS nsQueryInterface final
     return nsQueryInterfaceISupports::operator()(aIID, aAnswer);
   }
 };
+#endif  // #ifndef NSCAP_FEATURE_USE_BASE
 
 class MOZ_STACK_CLASS nsQueryInterfaceISupportsWithError {
  public:
@@ -174,6 +183,7 @@ class MOZ_STACK_CLASS nsQueryInterfaceISupportsWithError {
   nsresult* mErrorPtr;
 };
 
+#ifndef NSCAP_FEATURE_USE_BASE
 template <typename T>
 class MOZ_STACK_CLASS nsQueryInterfaceWithError final
     : public nsQueryInterfaceISupportsWithError {
@@ -185,6 +195,7 @@ class MOZ_STACK_CLASS nsQueryInterfaceWithError final
     return nsQueryInterfaceISupportsWithError::operator()(aIID, aAnswer);
   }
 };
+#endif  // #ifndef NSCAP_FEATURE_USE_BASE
 
 namespace mozilla {
 // PointedToType<> is needed so that do_QueryInterface() will work with a
@@ -194,6 +205,20 @@ template <class T>
 using PointedToType = std::remove_pointer_t<decltype(&*std::declval<T>())>;
 }  // namespace mozilla
 
+#ifdef NSCAP_FEATURE_USE_BASE
+template <class T>
+inline nsQueryInterfaceISupports do_QueryInterface(T aPtr) {
+  return nsQueryInterfaceISupports(
+      ToSupports(static_cast<mozilla::PointedToType<T>*>(aPtr)));
+}
+
+template <class T>
+inline nsQueryInterfaceISupportsWithError do_QueryInterface(T aPtr,
+                                                            nsresult* aError) {
+  return nsQueryInterfaceISupportsWithError(
+      ToSupports(static_cast<mozilla::PointedToType<T>*>(aPtr)), aError);
+}
+#else
 template <class T>
 inline nsQueryInterface<mozilla::PointedToType<T>> do_QueryInterface(T aPtr) {
   return nsQueryInterface<mozilla::PointedToType<T>>(aPtr);
@@ -205,6 +230,8 @@ inline nsQueryInterfaceWithError<mozilla::PointedToType<T>> do_QueryInterface(
   return nsQueryInterfaceWithError<mozilla::PointedToType<T>>(aRawPtr, aError);
 }
 
+#endif  // ! #ifdef NSCAP_FEATURE_USE_BASE
+
 template <class T>
 inline void do_QueryInterface(already_AddRefed<T>&) {
   // This signature exists solely to _stop_ you from doing the bad thing.
@@ -291,8 +318,20 @@ template <class T>
 char TestForIID(...);
 
 template <class T>
-class MOZ_IS_REFPTR nsCOMPtr final {
+class MOZ_IS_REFPTR nsCOMPtr final
+#ifdef NSCAP_FEATURE_USE_BASE
+    : private nsCOMPtr_base
+#endif
+{
  private:
+#ifdef NSCAP_FEATURE_USE_BASE
+#  define NSCAP_CTOR_BASE(x) nsCOMPtr_base(ToSupports(x))
+  void assign_assuming_AddRef(T* aNewPtr) {
+    nsCOMPtr_base::assign_assuming_AddRef(ToSupports(aNewPtr));
+  }
+#else
+#  define NSCAP_CTOR_BASE(x) mRawPtr(x)
+
   void assign_with_AddRef(nsISupports*);
   template <typename U>
   void assign_from_qi(const nsQueryInterface<U>, const nsIID&);
@@ -321,6 +360,7 @@ class MOZ_IS_REFPTR nsCOMPtr final {
 
  private:
   T* MOZ_OWNING_REF mRawPtr;
+#endif
 
   void assert_validity() {
     static_assert(1 < sizeof(TestForIID<T>(nullptr)),
@@ -334,12 +374,14 @@ class MOZ_IS_REFPTR nsCOMPtr final {
  public:
   typedef T element_type;
 
+#ifndef NSCAP_FEATURE_USE_BASE
   ~nsCOMPtr() {
     NSCAP_LOG_RELEASE(this, mRawPtr);
     if (mRawPtr) {
       NSCAP_RELEASE(this, mRawPtr);
     }
   }
+#endif
 
 #ifdef NSCAP_FEATURE_TEST_DONTQUERY_CASES
   void Assert_NoQueryNeeded() {
@@ -367,17 +409,17 @@ class MOZ_IS_REFPTR nsCOMPtr final {
 
   // Constructors
 
-  nsCOMPtr() : mRawPtr(nullptr) {
+  nsCOMPtr() : NSCAP_CTOR_BASE(nullptr) {
     assert_validity();
     NSCAP_LOG_ASSIGNMENT(this, nullptr);
   }
 
-  MOZ_IMPLICIT nsCOMPtr(decltype(nullptr)) : mRawPtr(nullptr) {
+  MOZ_IMPLICIT nsCOMPtr(decltype(nullptr)) : NSCAP_CTOR_BASE(nullptr) {
     assert_validity();
     NSCAP_LOG_ASSIGNMENT(this, nullptr);
   }
 
-  nsCOMPtr(const nsCOMPtr<T>& aSmartPtr) : mRawPtr(aSmartPtr.mRawPtr) {
+  nsCOMPtr(const nsCOMPtr<T>& aSmartPtr) : NSCAP_CTOR_BASE(aSmartPtr.mRawPtr) {
     assert_validity();
     if (mRawPtr) {
       NSCAP_ADDREF(this, mRawPtr);
@@ -387,7 +429,7 @@ class MOZ_IS_REFPTR nsCOMPtr final {
 
   template <class U>
   MOZ_IMPLICIT nsCOMPtr(const nsCOMPtr<U>& aSmartPtr)
-      : mRawPtr(aSmartPtr.get()) {
+      : NSCAP_CTOR_BASE(aSmartPtr.get()) {
     // Make sure that U actually inherits from T
     static_assert(std::is_base_of<T, U>::value, "U should be a subclass of T");
     assert_validity();
@@ -397,7 +439,7 @@ class MOZ_IS_REFPTR nsCOMPtr final {
     NSCAP_LOG_ASSIGNMENT(this, aSmartPtr.get());
   }
 
-  nsCOMPtr(nsCOMPtr<T>&& aSmartPtr) : mRawPtr(aSmartPtr.mRawPtr) {
+  nsCOMPtr(nsCOMPtr<T>&& aSmartPtr) : NSCAP_CTOR_BASE(aSmartPtr.mRawPtr) {
     assert_validity();
     aSmartPtr.mRawPtr = nullptr;
     NSCAP_LOG_ASSIGNMENT(this, mRawPtr);
@@ -405,7 +447,7 @@ class MOZ_IS_REFPTR nsCOMPtr final {
 
   template <class U>
   MOZ_IMPLICIT nsCOMPtr(nsCOMPtr<U>&& aSmartPtr)
-      : mRawPtr(aSmartPtr.forget().template downcast<T>().take()) {
+      : NSCAP_CTOR_BASE(aSmartPtr.forget().template downcast<T>().take()) {
     // Make sure that U actually inherits from T
     static_assert(std::is_base_of<T, U>::value, "U should be a subclass of T");
     assert_validity();
@@ -413,7 +455,7 @@ class MOZ_IS_REFPTR nsCOMPtr final {
     NSCAP_ASSERT_NO_QUERY_NEEDED();
   }
 
-  MOZ_IMPLICIT nsCOMPtr(T* aRawPtr) : mRawPtr(aRawPtr) {
+  MOZ_IMPLICIT nsCOMPtr(T* aRawPtr) : NSCAP_CTOR_BASE(aRawPtr) {
     assert_validity();
     if (mRawPtr) {
       NSCAP_ADDREF(this, mRawPtr);
@@ -423,7 +465,7 @@ class MOZ_IS_REFPTR nsCOMPtr final {
   }
 
   MOZ_IMPLICIT nsCOMPtr(already_AddRefed<T>& aSmartPtr)
-      : mRawPtr(aSmartPtr.take()) {
+      : NSCAP_CTOR_BASE(aSmartPtr.take()) {
     assert_validity();
     NSCAP_LOG_ASSIGNMENT(this, mRawPtr);
     NSCAP_ASSERT_NO_QUERY_NEEDED();
@@ -431,7 +473,7 @@ class MOZ_IS_REFPTR nsCOMPtr final {
 
   // Construct from |otherComPtr.forget()|.
   MOZ_IMPLICIT nsCOMPtr(already_AddRefed<T>&& aSmartPtr)
-      : mRawPtr(aSmartPtr.take()) {
+      : NSCAP_CTOR_BASE(aSmartPtr.take()) {
     assert_validity();
     NSCAP_LOG_ASSIGNMENT(this, mRawPtr);
     NSCAP_ASSERT_NO_QUERY_NEEDED();
@@ -440,7 +482,8 @@ class MOZ_IS_REFPTR nsCOMPtr final {
   // Construct from |std::move(otherRefPtr)|.
   template <typename U>
   MOZ_IMPLICIT nsCOMPtr(RefPtr<U>&& aSmartPtr)
-      : mRawPtr(static_cast<already_AddRefed<T>>(aSmartPtr.forget()).take()) {
+      : NSCAP_CTOR_BASE(
+            static_cast<already_AddRefed<T>>(aSmartPtr.forget()).take()) {
     assert_validity();
     // Make sure that U actually inherits from T
     static_assert(std::is_base_of<T, U>::value, "U is not a subclass of T");
@@ -451,7 +494,7 @@ class MOZ_IS_REFPTR nsCOMPtr final {
   // Construct from |already_AddRefed|.
   template <typename U>
   MOZ_IMPLICIT nsCOMPtr(already_AddRefed<U>& aSmartPtr)
-      : mRawPtr(static_cast<T*>(aSmartPtr.take())) {
+      : NSCAP_CTOR_BASE(static_cast<T*>(aSmartPtr.take())) {
     assert_validity();
     // But make sure that U actually inherits from T.
     static_assert(std::is_base_of<T, U>::value, "U is not a subclass of T");
@@ -462,7 +505,7 @@ class MOZ_IS_REFPTR nsCOMPtr final {
   // Construct from |otherComPtr.forget()|.
   template <typename U>
   MOZ_IMPLICIT nsCOMPtr(already_AddRefed<U>&& aSmartPtr)
-      : mRawPtr(static_cast<T*>(aSmartPtr.take())) {
+      : NSCAP_CTOR_BASE(static_cast<T*>(aSmartPtr.take())) {
     assert_validity();
     // But make sure that U actually inherits from T.
     static_assert(std::is_base_of<T, U>::value, "U is not a subclass of T");
@@ -471,24 +514,34 @@ class MOZ_IS_REFPTR nsCOMPtr final {
   }
 
   // Construct from |do_QueryInterface(expr)|.
+#ifdef NSCAP_FEATURE_USE_BASE
+  MOZ_IMPLICIT nsCOMPtr(const nsQueryInterfaceISupports aQI)
+#else
   template <typename U>
-  MOZ_IMPLICIT nsCOMPtr(const nsQueryInterface<U> aQI) : mRawPtr(nullptr) {
+  MOZ_IMPLICIT nsCOMPtr(const nsQueryInterface<U> aQI)
+#endif  // ! #ifdef NSCAP_FEATURE_USE_BASE
+      : NSCAP_CTOR_BASE(nullptr) {
     assert_validity();
     NSCAP_LOG_ASSIGNMENT(this, nullptr);
     assign_from_qi(aQI, NS_GET_TEMPLATE_IID(T));
   }
 
   // Construct from |do_QueryInterface(expr, &rv)|.
+#ifdef NSCAP_FEATURE_USE_BASE
+  MOZ_IMPLICIT nsCOMPtr(const nsQueryInterfaceISupportsWithError& aQI)
+#else
   template <typename U>
   MOZ_IMPLICIT nsCOMPtr(const nsQueryInterfaceWithError<U>& aQI)
-      : mRawPtr(nullptr) {
+#endif  // ! #ifdef NSCAP_FEATURE_USE_BASE
+      : NSCAP_CTOR_BASE(nullptr) {
     assert_validity();
     NSCAP_LOG_ASSIGNMENT(this, nullptr);
     assign_from_qi_with_error(aQI, NS_GET_TEMPLATE_IID(T));
   }
 
   // Construct from |do_GetService(cid_expr)|.
-  MOZ_IMPLICIT nsCOMPtr(const nsGetServiceByCID aGS) : mRawPtr(nullptr) {
+  MOZ_IMPLICIT nsCOMPtr(const nsGetServiceByCID aGS)
+      : NSCAP_CTOR_BASE(nullptr) {
     assert_validity();
     NSCAP_LOG_ASSIGNMENT(this, nullptr);
     assign_from_gs_cid(aGS, NS_GET_TEMPLATE_IID(T));
@@ -496,14 +549,15 @@ class MOZ_IS_REFPTR nsCOMPtr final {
 
   // Construct from |do_GetService(cid_expr, &rv)|.
   MOZ_IMPLICIT nsCOMPtr(const nsGetServiceByCIDWithError& aGS)
-      : mRawPtr(nullptr) {
+      : NSCAP_CTOR_BASE(nullptr) {
     assert_validity();
     NSCAP_LOG_ASSIGNMENT(this, nullptr);
     assign_from_gs_cid_with_error(aGS, NS_GET_TEMPLATE_IID(T));
   }
 
   // Construct from |do_GetService(contractid_expr)|.
-  MOZ_IMPLICIT nsCOMPtr(const nsGetServiceByContractID aGS) : mRawPtr(nullptr) {
+  MOZ_IMPLICIT nsCOMPtr(const nsGetServiceByContractID aGS)
+      : NSCAP_CTOR_BASE(nullptr) {
     assert_validity();
     NSCAP_LOG_ASSIGNMENT(this, nullptr);
     assign_from_gs_contractid(aGS, NS_GET_TEMPLATE_IID(T));
@@ -511,7 +565,7 @@ class MOZ_IS_REFPTR nsCOMPtr final {
 
   // Construct from |do_GetService(contractid_expr, &rv)|.
   MOZ_IMPLICIT nsCOMPtr(const nsGetServiceByContractIDWithError& aGS)
-      : mRawPtr(nullptr) {
+      : NSCAP_CTOR_BASE(nullptr) {
     assert_validity();
     NSCAP_LOG_ASSIGNMENT(this, nullptr);
     assign_from_gs_contractid_with_error(aGS, NS_GET_TEMPLATE_IID(T));
@@ -519,7 +573,7 @@ class MOZ_IS_REFPTR nsCOMPtr final {
 
   // Construct from |do_QueryReferent(ptr)|
   MOZ_IMPLICIT nsCOMPtr(const nsQueryReferent& aQueryReferent)
-      : mRawPtr(nullptr) {
+      : NSCAP_CTOR_BASE(nullptr) {
     assert_validity();
     NSCAP_LOG_ASSIGNMENT(this, nullptr);
     assign_from_query_referent(aQueryReferent, NS_GET_TEMPLATE_IID(T));
@@ -527,7 +581,8 @@ class MOZ_IS_REFPTR nsCOMPtr final {
 
   // And finally, anything else we might need to construct from can exploit the
   // nsCOMPtr_helper facility.
-  MOZ_IMPLICIT nsCOMPtr(const nsCOMPtr_helper& aHelper) : mRawPtr(nullptr) {
+  MOZ_IMPLICIT nsCOMPtr(const nsCOMPtr_helper& aHelper)
+      : NSCAP_CTOR_BASE(nullptr) {
     assert_validity();
     NSCAP_LOG_ASSIGNMENT(this, nullptr);
     assign_from_helper(aHelper, NS_GET_TEMPLATE_IID(T));
@@ -539,14 +594,14 @@ class MOZ_IS_REFPTR nsCOMPtr final {
             typename = std::enable_if_t<!std::is_same_v<I, nsCOMPtr<T>> &&
                                         std::is_convertible_v<I, nsCOMPtr<T>>>>
   MOZ_IMPLICIT nsCOMPtr(const mozilla::NotNull<I>& aSmartPtr)
-      : mRawPtr(nsCOMPtr<T>(aSmartPtr.get()).forget().take()) {}
+      : NSCAP_CTOR_BASE(nsCOMPtr<T>(aSmartPtr.get()).forget().take()) {}
 
   // construct from |mozilla::MovingNotNull|.
   template <typename I,
             typename = std::enable_if_t<!std::is_same_v<I, nsCOMPtr<T>> &&
                                         std::is_convertible_v<I, nsCOMPtr<T>>>>
   MOZ_IMPLICIT nsCOMPtr(mozilla::MovingNotNull<I>&& aSmartPtr)
-      : mRawPtr(
+      : NSCAP_CTOR_BASE(
             nsCOMPtr<T>(std::move(aSmartPtr).unwrapBasePtr()).forget().take()) {
   }
 
@@ -625,15 +680,25 @@ class MOZ_IS_REFPTR nsCOMPtr final {
   }
 
   // Assign from |do_QueryInterface(expr)|.
+#ifdef NSCAP_FEATURE_USE_BASE
+  nsCOMPtr<T>& operator=(const nsQueryInterfaceISupports aRhs)
+#else
   template <typename U>
-  nsCOMPtr<T>& operator=(const nsQueryInterface<U> aRhs) {
+  nsCOMPtr<T>& operator=(const nsQueryInterface<U> aRhs)
+#endif  // ! #ifdef NSCAP_FEATURE_USE_BASE
+  {
     assign_from_qi(aRhs, NS_GET_TEMPLATE_IID(T));
     return *this;
   }
 
   // Assign from |do_QueryInterface(expr, &rv)|.
+#ifdef NSCAP_FEATURE_USE_BASE
+  nsCOMPtr<T>& operator=(const nsQueryInterfaceISupportsWithError& aRhs)
+#else
   template <typename U>
-  nsCOMPtr<T>& operator=(const nsQueryInterfaceWithError<U>& aRhs) {
+  nsCOMPtr<T>& operator=(const nsQueryInterfaceWithError<U>& aRhs)
+#endif  // ! #ifdef NSCAP_FEATURE_USE_BASE
+  {
     assign_from_qi_with_error(aRhs, NS_GET_TEMPLATE_IID(T));
     return *this;
   }
@@ -699,7 +764,11 @@ class MOZ_IS_REFPTR nsCOMPtr final {
 
   // Exchange ownership with |aRhs|; can save a pair of refcount operations.
   void swap(nsCOMPtr<T>& aRhs) {
+#ifdef NSCAP_FEATURE_USE_BASE
+    nsISupports* temp = aRhs.mRawPtr;
+#else
     T* temp = aRhs.mRawPtr;
+#endif
     NSCAP_LOG_ASSIGNMENT(&aRhs, mRawPtr);
     NSCAP_LOG_ASSIGNMENT(this, temp);
     NSCAP_LOG_RELEASE(this, mRawPtr);
@@ -712,7 +781,11 @@ class MOZ_IS_REFPTR nsCOMPtr final {
 
   // Exchange ownership with |aRhs|; can save a pair of refcount operations.
   void swap(T*& aRhs) {
+#ifdef NSCAP_FEATURE_USE_BASE
+    nsISupports* temp = ToSupports(aRhs);
+#else
     T* temp = aRhs;
+#endif
     NSCAP_LOG_ASSIGNMENT(this, temp);
     NSCAP_LOG_RELEASE(this, mRawPtr);
     aRhs = reinterpret_cast<T*>(mRawPtr);
@@ -801,6 +874,7 @@ inline void ImplCycleCollectionTraverse(
   CycleCollectionNoteChild(aCallback, aField.get(), aName, aFlags);
 }
 
+#ifndef NSCAP_FEATURE_USE_BASE
 template <class T>
 void nsCOMPtr<T>::assign_with_AddRef(nsISupports* aRawPtr) {
   if (aRawPtr) {
@@ -910,6 +984,7 @@ void** nsCOMPtr<T>::begin_assignment() {
   result.mT = &mRawPtr;
   return result.mVoid;
 }
+#endif
 
 template <class T>
 inline nsCOMPtr<T>* address_of(nsCOMPtr<T>& aPtr) {
-- 
2.41.0

